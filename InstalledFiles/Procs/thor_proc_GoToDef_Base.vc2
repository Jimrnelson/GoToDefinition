*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="thor_proc_gotodef_base.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS basecustom AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="2022/11/28 09:57:26" Scale="Pixels" Uniqueid="" />

	#INCLUDE "gotodefinition.h"
	*<DefinedPropArrayMethod>
		*m: addmrufile		&& Adds a file (or class within a file) to its appropriate VFP MRU list.  The last parameter is optional (can be inferred from the filename, after all)
		*m: atspecial
		*m: browsefile
		*m: checkoutscc
		*m: diskfilename		&& Returns the file name with the same case (upper/lower) as it is on disk.
		*m: editlocalmethodcode
		*m: editsourcex		&& Enhanced version of VFP's EditSource: maintains case of file name, adds to MRU list, optionally checks out from source control.  For classes, opens up class browser.  For PRGs and text files, start and end points of text to be selected may be supplied.
		*m: findtopmostparent
		*m: findwith
		*m: focusoncontrol
		*m: getcontrolcount		&& Returns the number of child objects in a container object
		*m: getcurrentincludefile
		*m: getincludefiles		&& Returns list of include files
		*m: getmousecoordinates
		*m: getmruid		&& Returns the name of the MRU list associated with a file name or extension)
		*m: getmrulist		&& Returns (as a collection) the list of all items for a particular MRU list.  <lcMRU_ID> may be the actual MRU name, a file name, or a file extension
		*m: getobjectpath
		*m: getpemstatus
		*m: getpluginpath
		*m: getregexp
		*m: getrelativepath
		*m: getthoroption
		*m: isnamechar
		*m: movewindow
		*m: opemeditorutils_access
		*m: opemeditor_access
		*m: openurl
		*m: oprefs_access
		*m: pix2fox
		*m: release		&& Releases a FormSet or Form from memory.
		*m: showerrormsg
		*m: showhelp
		*m: striptabs
		*m: viewparentcode
		*m: viewtempfile
		*p: lreleaseondestroy
		*p: opemeditor
		*p: opemeditorutils
		*p: oprefs
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN height,helpcontextid
	lreleaseondestroy = .F.
	Name = "basecustom"
	opemeditor = .NULL.
	opemeditorutils = .NULL.
	oprefs = .NULL.
	_memberdata = <VFPData>
		<memberdata name="release" display="Release"/>
		<memberdata name="addmrufile" display="AddMRUFile"/>
		<memberdata name="diskfilename" display="DiskFileName"/>
		<memberdata name="getcontrolcount" display="GetControlCount"/>
		<memberdata name="getpemstatus" display="GetPEMStatus"/>
		<memberdata name="getrelativepath" display="GetRelativePath"/>
		<memberdata name="isnamechar" display="IsNameChar"/>
		<memberdata name="openurl" display="OpenURL"/>
		<memberdata name="showerrormsg" display="ShowErrorMsg"/>
		<memberdata name="showhelp" display="ShowHelp"/>
		<memberdata name="striptabs" display="StripTabs"/>
		<memberdata name="getmrulist" display="GetMRUList"/>
		<memberdata name="editsourcex" display="EditSourceX"/>
		<memberdata name="getmruid" display="GetMRUID"/>
		<memberdata name="checkoutscc" display="CheckOutSCC"/>
		<memberdata name="atspecial" type="method" display="AtSpecial"/>
		<memberdata name="getpluginpath" display="GetPlugInPath"/>
		<memberdata name="browsefile" display="BrowseFile"/>
		<memberdata name="getthoroption" type="method" display="GetThorOption"/>
		<memberdata name="editlocalmethodcode" display="EditLocalMethodCode"/>
		<memberdata name="findtopmostparent" display="FindTopMostParent"/>
		<memberdata name="focusoncontrol" display="FocusOnControl"/>
		<memberdata name="getcurrentincludefile" display="GetCurrentIncludeFile"/>
		<memberdata name="getincludefiles" display="GetIncludeFiles"/>
		<memberdata name="getobjectpath" display="GetObjectPath"/>
		<memberdata name="getregexp" display="GetRegExp"/>
		<memberdata name="viewtempfile" display="ViewTempFile"/>
		<memberdata name="opemeditorutils" display="oPEMEditorUtils"/>
		<memberdata name="opemeditorutils_access" display="oPEMEditorUtils_Access"/>
		<memberdata name="oprefs" display="oPrefs"/>
		<memberdata name="oprefs_access" display="oPrefs_Access"/>
		<memberdata name="opemeditor" display="oPEMEditor"/>
		<memberdata name="opemeditor_access" display="oPEMEditor_Access"/>
		<memberdata name="movewindow" display="MoveWindow"/>
		<memberdata name="findwith" display="FindWith"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addmrufile		&& Adds a file (or class within a file) to its appropriate VFP MRU list.  The last parameter is optional (can be inferred from the filename, after all)
		Lparameters lcFileName, lcClassName, lcMRU_ID
		
		#Define DELIMITERCHAR  Chr(0)
		#Define MAXITEMS       24
		#Define ResourceAlias  crsr_MRU_Resource_Add
		
		Local lcData, lcLine25, lcNewData, lcSearchString, lcSourceFile, lnPos, lnSelect
		
		If 'ON' # Set ('Resource')
			Return
		Endif
		
		If lcFileName # '\-'
			lcFileName = This.DiskFileName(FullPath(lcFileName))
		EndIf
		
		lcSourceFile = Set ('Resource', 1)
		
		If Empty (lcMRU_ID)
			lcMRU_ID = This.GetMRUID (lcFileName)
			If '?' $ lcMRU_ID
				Return
			Endif
		Endif
		
		If lcMRU_ID = 'MRUI'
			If Empty (lcClassName) && Class library (artificial)
				lcMRU_ID	   = 'MRU2'
				lcSearchString = lcFileName + DELIMITERCHAR
			Else
				lcSearchString = lcFileName + '|' + Lower (lcClassName) + DELIMITERCHAR
				This.AddMRUFile(lcFileName, , 'MRU2')
			Endif
		Else
			lcSearchString = lcFileName + DELIMITERCHAR
		Endif
		
		lnSelect = Select()
		Select 0
		Use (lcSourceFile) Again Shared Alias ResourceAlias
		
		Locate For Id = lcMRU_ID
		If Found()
			lcData = DELIMITERCHAR + Substr (Data, 3)
			lnPos  = Atcc (DELIMITERCHAR + lcSearchString, lcData)
			Do Case
				Case lnPos = 1
					* already tops of the list
					lcNewData = Data
				Case lnPos = 0
					* must add to list
					lcNewData = Stuff (Data, 3, 0, lcSearchString)
					* note that GetWordNum won't accept CHR(0) as a delimiter
					lcLine25  = Getwordnum (Chrtran (Substr (lcNewData, 3), DELIMITERCHAR, CR), MAXITEMS + 1, CR)
					If Not Empty (lcLine25)
						lcNewData = Strtran (lcNewData, DELIMITERCHAR + lcLine25 + DELIMITERCHAR, DELIMITERCHAR, 1, 1, 1)
					Endif
				Otherwise
					lcNewData = Stuff (Data, lnPos + 1, Len (lcSearchString), '')
					lcNewData = Stuff (lcNewData, 3, 0, lcSearchString)
			Endcase
			Replace																;
					Data	 With  lcNewData									;
					ckval	 With  Val (Sys(2007, Substr (lcNewData, 3)))		;
					Updated	 With  Date()
		Else
			lcNewData = Chr(4) + DELIMITERCHAR + lcSearchString
			Insert Into ResourceAlias					;
				(Type, Id, ckval, Data, Updated)		;
				Values									;
				('PREFW', lcMRU_ID, Val (Sys(2007, Substr (lcNewData, 3))), lcNewData, Date())
		
			****************************************************************
		Endif
		
		Use
		Select (lnSelect)
		
		Return
		
	ENDPROC

	PROCEDURE atspecial
		Lparameters lcSearchExpr, lcSearched
		
		Return Evl ( At (lcSearchExpr, lcSearched), 1 + Len (lcSearched))
	ENDPROC

	PROCEDURE browsefile
		Lparameters lcFileName, lnRecNo
		Local lcAlias, llSuccess, lnDataSession, lnSelect, loException
		
		lnDataSession = Set('Datasession')
		Set DataSession To 1
		lnSelect = Select()
		
		Try
			Select 0
			Use (m.lcFileName) Again Shared
			lcAlias = Alias()
		
			If Not Empty(m.lnRecNo)
				Goto m.lnRecNo
			Endif
		
			llSuccess = Execscript (_Screen.cThorDispatcher, 'Thor_Proc_SuperBrowse', m.lcAlias)
		Catch To m.loException
			This.ShowErrorMsg (m.loException)
			llSuccess = .F.
		Endtry
		
		Select (m.lnSelect)
		Set DataSession To (m.lnDataSession)
		Return m.llSuccess
		
	ENDPROC

	PROCEDURE checkoutscc
		Lparameters lcFileName
		
		Local lnSelect, loException
		
		*** JRN 11/17/2010 : Bhavbhuti: Source Control
		* Select 0 -- used because it appears that CheckOut may kill current work area
		If 'O' = Type ('This.oPrefs') And This.oPrefs.lCheckOutSCC And 0 # _vfp.Projects.Count
			lnSelect = Select()
			Select 0
			Try
				If Not Inlist (_vfp.ActiveProject.Files (m.lcFileName).SCCStatus, 0, 2)
					If Not _vfp.ActiveProject.Files (m.lcFileName).CheckOut()
		
					Endif
				Endif
			Catch To m.loException
				Do Case
					Case m.loException.ErrorNo = 1943 && if not found in this project
					Case m.loException.ErrorNo = 1426 && OLE error code 0x85ff012e: Unknown COM status code
						_vfp.ActiveProject.Files (m.lcFileName).CheckOut()
					Otherwise
						This.ShowErrorMsg(m.loException)
				Endcase
			Endtry
			Select (m.lnSelect)
		Endif
		
		
	ENDPROC

	PROCEDURE Destroy
		This.Release()
		
	ENDPROC

	PROCEDURE diskfilename		&& Returns the file name with the same case (upper/lower) as it is on disk.
		Lparameters lcFileName
		
		#Define MAX_PATH 260
		
		Local lnFindFileData, lnHandle, lcXXX
		Declare Integer FindFirstFile In win32api String @, String @
		Declare Integer FindNextFile In win32api Integer, String @
		Declare Integer FindClose In win32api Integer
		
		Do Case
			Case ( Right (lcFileName, 1) == '\' )
				Return Addbs (This.DiskFileName (Left (lcFileName, Len (lcFileName) - 1)))
		
			Case Empty (lcFileName)
				Return ''
		
			Case ( Len (lcFileName) == 2 ) And ( Right (lcFileName, 1) == ':' )
				Return Upper (lcFileName)	&& win2k gives curdir() for C:
		Endcase
		
		lnFindFileData = Space(4 + 8 + 8 + 8 + 4 + 4 + 4 + 4 + MAX_PATH + 14)
		lnHandle		 = FindFirstFile (@lcFileName, @lnFindFileData)
		
		If ( lnHandle < 0 )
			If ( Not Empty (Justfname (lcFileName)) )
				lcXXX = Justfname (lcFileName)
			Else
				lcXXX = lcFileName
			Endif
		Else
			= FindClose (lnHandle)
			lcXXX	= Substr (lnFindFileData, 45, MAX_PATH)
			lcXXX	= Left (lcXXX, At (Chr(0), lcXXX) - 1)
		Endif
		
		
		Do Case
			Case Empty (Justpath (lcFileName))
				Return lcXXX
			Case ( Justpath (lcFileName) == '\' ) Or (Left (lcFileName, 2) == '\\')	&& unc
				Return '\\' + lcXXX
			Otherwise
				Return Addbs (This.DiskFileName (Justpath (lcFileName))) + lcXXX
		Endcase
		
		Return
		
	ENDPROC

	PROCEDURE editlocalmethodcode
		Lparameters lcFileName, loTopOfForm, toObject, lcMethod, llClass, llDataEnvironment
		
		Local loContainerObj As Object
		Local loObject As Object
		Local laObject[1], lcClassName, lcExpression, lcObjectName, lcParams, lcPem, lnStartRange
		
		If 'O' # Vartype (loTopOfForm)
			loTopOfForm = This.FindTopMostParent()
			If Isnull (loTopOfForm)
				Return .F.
			Endif
		Endif
		
		loObject = toObject
		
		Do Case
			Case Not llDataEnvironment
				If llClass
					lcClassName	= loTopOfForm.Name
					lcPem		= ''
				Else
					lcClassName	= ''
					lcPem		= loObject.Name + '.'
				Endif
		
				*** JRN 02/28/2009 : up through the parent to the top form/class
				Aselobj (laObject, 3)
				loContainerObj = laObject[ 1 ]
		
				Do While loContainerObj # loTopOfForm
					loContainerObj = loContainerObj.Parent
					If 'grid' # Lower (loContainerObj.BaseClass)
						lcPem = lcPem + 'Parent.'
					Endif
				Enddo
		
				*** JRN 02/28/2009 : and now drill down to the object
		
				loTopOfForm	 = loTopOfForm
				lcObjectName = ''
				Do While loObject # loTopOfForm
					lcObjectName = loObject.Name + '.' + lcObjectName
					loObject	 = loObject.Parent
				Enddo
				lcPem = lcPem + lcObjectName + lcMethod
		
			Case Lower (loObject.BaseClass) = Lower ('DataEnvironment')
				lcClassName	= ''
				lcPem		= loTopOfForm.Name + '.' + loObject.Name + '.' + lcMethod
		
			Otherwise
				lcClassName	= ''
				lcPem		= loTopOfForm.Name + '.' + loObject.Parent.Name + '.' + loObject.Name + '.' + lcMethod
		
		Endcase
		
		*	Editsource (lcFileName, lnStartRange, lcClassName, lcPem)
		lnStartRange = 0
		lcParams = 'lcFileName, lnStartRange, lcClassName, lcPem'
		lcExpression = 'lParameters ' + lcParams + ccCR + 'Editsource(' + lcParams + ')'
		Execscript(lcExpression, &lcParams)
		
		DoEvents
		
		If This.oPrefs.lAutoMoveWindow
			This.MoveWindow()
		Endif
		
		If 'O' = Vartype (This.oPEMEditor)
			This.oPEMEditor.RenameMethodWindow (toObject, lcMethod)
		Endif
		
		
	ENDPROC

	PROCEDURE editsourcex		&& Enhanced version of VFP's EditSource: maintains case of file name, adds to MRU list, optionally checks out from source control.  For classes, opens up class browser.  For PRGs and text files, start and end points of text to be selected may be supplied.
		Lparameters tcFileName, tcClass, tcMethod, tnStartRange, tnEndRange, tlCheckOutSCC
		
		Local lcClass, lcCustomPRG, lcExpression, lcExt, lcFileName, lcMethod, lcNewName, lcParams
		Local llSuccess, lnEndRange, lnSelect, lnStartRange, loException
		
		lcFileName	 = This.DiskFileName(Trim(tcFileName))
		lcClass		 = Trim(Evl(tcClass, ''))
		lnStartRange = Evl(tnStartRange, 0)
		lnEndRange	 = Evl(tnEndRange, 1)
		lcMethod	 = Evl(tcMethod, '')
		lcExt		 = Upper (Justext (lcFileName))
		
		This.AddMRUFile (lcFileName, lcClass)
		
		Try
			If lcExt = 'PJX'
				Modify Project (lcFileName) Nowait
			Else
				If Pcount() < 6 Or tlCheckOutSCC
					lnSelect = Select()
					Select 0
					This.CheckOutSCC (lcFileName)
					Select (lnSelect)
				Endif
				Do Case
					Case lcExt = 'VCX' And Empty(lcClass)
						lcCustomPRG =  This.GetPlugInPath ('OpenVCXFile')
						If Not Empty (lcCustomPRG)
							Try
								lcNewName = Execscript(Filetostr(lcCustomPRG), lcFileName)
							Catch To loException
								This.ShowErrorMsg(loException, 'Open VCX File Failure', lcCustomPRG)
							Endtry
						Else
							Do(_Browser) With (lcFileName)
						Endif
					Case lcExt $ ' SCX VCX FRX LBX MNX DBC '
						lcParams	 = 'lcFileName, lnStartRange, lcClass, lcMethod'
						lcExpression = 'lParameters ' + lcParams + ccCR + 'Editsource(' + lcParams + ')'
						Execscript(lcExpression, &lcParams)
					Case lcExt == 'PRG'
						If lnStartRange # 0
							Modify Command(lcFileName) Range lnStartRange, lnEndRange Nowait
						Else
							Modify Command(lcFileName) Nowait
						Endif
					Case (' ' + lcExt + ' ') $ ccTextFileExtensions
						If lnStartRange # 0
							Modify File(lcFileName) Range lnStartRange, lnEndRange Nowait
						Else
							Modify File(lcFileName) Nowait
						Endif
					Case lcExt == 'DBF'
						llSuccess = This.BrowseFile(lcFileName, tnStartRange)
					Case (' ' + lcExt + ' ') $ ' DBC '
						*** can't open of these files
						Return .F.
					Otherwise
						lcCustomPRG = This.GetPlugInPath ('EditSourceX')
						If Not Empty (lcCustomPRG)
							Try
								lcNewName = Execscript(Filetostr(lcCustomPRG), lcFileName)
							Catch To loException
								This.ShowErrorMsg(loException, 'EditSourceX plug-in failure', lcCustomPRG)
							Endtry
						Else
							This.OpenURL (lcFileName)
						Endif
				Endcase
			Endif
			llSuccess = .T.
		Catch To loException
			This.ShowErrorMsg (loException)
			llSuccess = .F.
		Endtry
		
		Return llSuccess
		*!*	Try
		*!*		Do Case
		*!*			Case lcExt = 'PJX'
		*!*				Modify Project (lcFileName) Nowait
		*!*			Case lcExt = 'VCX' And Empty (lcClass)
		*!*				This.CheckOutSCC (lcFileName)
		*!*				Do (_Browser) With (lcFileName)
		*!*			Otherwise
		*!*				This.CheckOutSCC (lcFileName)
		*!*				Do Case
		*!*					Case Not Empty (lcClass)
		*!*						Editsource (lcFileName, 0, lcClass)
		*!*					Case 'N' = Vartype (lnStartRange)
		*!*						If 'PRG' == lcExt
		*!*							Modify Command (lcFileName) Range lnStartRange, lnEndRange Nowait
		*!*						Else
		*!*							Modify File (lcFileName) Range lnStartRange, lnEndRange Nowait
		*!*						Endif
		*!*					Case (' ' + lcExt + ' ') $ ' PRG MPR QPR TXT H INI SCX VCX FRX LBX MNX DBC '
		*!*						Editsource (lcFileName)
		*!*					Otherwise
		*!*						This.OpenURL (lcFileName)
		*!*				Endcase
		*!*		Endcase
		*!*	Catch To loException
		*!*		This.ShowErrorMsg (loException)
		*!*	Endtry
		
		
	ENDPROC

	PROCEDURE findtopmostparent
		Local laObject[1], loTopOfForm
		
		If 0 # Aselobj (laObject, 3)
			This.cSourceFileName = Lower (laObject[2])
			This.lClass			 = Justext (This.cSourceFileName) == 'vcx'
			loTopOfForm			 = This.PEME_FindTopmostParent (laObject[1], This.lClass)
		
			Return loTopOfForm
		
		Else
		
			Return .Null.
		
		Endif
		
	ENDPROC

	PROCEDURE findwith
		*** JRN 2010-04-03 : From Tamar's ControlRenamer
		* modified to remove any annoying tabs
		
		Lparameters nStartLine
		
		* Find the first occurrence of WITH preceding
		* the specified line and extract the referenced object
		
		Local cContainer, cObject, cWithLine, nLine, nNamePos, nWITHLevel
		
		If nStartLine <= 1
			Return ''
		Endif
		
		*** JRN 2010-04-04 : corrected for WITH on first line
		* also handles intervening (and ignorable) WITH/ENDWITHs
		nWITHLevel = 0
		For nLine = nStartLine - 1 To 1 Step - 1
			cWithLine = This.StripTabs (This.aProcLines[nLine])
		
			Do Case
				Case Upper(cWithLine) = "WITH " And nWITHLevel = 0
					nNamePos = At(" ", Alltrim(cWithLine))
					cObject = Alltrim(Substr(cWithLine, nNamePos + 1))
					* Remove trailing period
					If Right(cObject,1)="."
						cObject = Left(cObject, Len(cObject)-1)
					Endif
					If Left(cObject, 1) = "."
						* Nested WITH, keep going back
						cContainer = This.FindWith(nLine)
						cObject = cContainer + cObject
					Endif
					Return cObject
				Case Upper(cWithLine) = "ENDW"
					nWITHLevel = nWITHLevel + 1
				Case Upper(cWithLine) = "WITH "
					nWITHLevel = nWITHLevel - 1
			Endcase
		
		Endfor && nLine = nStartLine - 1 To 1 Step - 1
		
		Return ''
		
	ENDPROC

	PROCEDURE focusoncontrol
		* concept from ControlRenamer by Tamar
		Lparameters loControl
		
		Local loTopOfForm As Object
		Local laStartMouseObj[1], lcBaseClass, lcWindow, lcWindowName, llFound, llNoWindow
		
		*** JRN 7/10/2012 : Setup; capture current mouse position and window name
		
		If Lower (loControl.BaseClass) = 'formset'
			Return
		Endif
		
		Amouseobj (laStartMouseObj, 1)
		
		Try
			lcWindowName = This.GetMyWindowName()
			Activate Window (lcWindowName)
			llNoWindow = .F.
		Catch
			llNoWindow = .T.
		Endtry
		
		If llNoWindow
			Return
		Endif
		
		llFound		= .F.
		loTopOfForm	= This.FindTopMostParent()
		
		********************************************************************************
		
		lcBaseClass = Lower(loControl.BaseClass)
		
		Do Case
			Case This.SetFocusToControl(loControl)
		
			Case lcBaseClass = 'pageframe'
				This.ClickOnControl(loControl, lcWindowName, '', .F., loTopOfForm)
		
			Case Inlist(lcBaseClass, 'form', 'page', 'container', 'optiongroup')
				This.ClickOnContainer(loControl, lcWindowName, loTopOfForm)
		
			Otherwise
				This.ClickOnControl(loControl, lcWindowName, 'Shift Control', .T., loTopOfForm)
		Endcase
		
		
		********************************************************************************
		*** JRN 2010-03-06 : Restore mouse to original position
		If Alen (laStartMouseObj) >= 4 And 'O' = Vartype (laStartMouseObj(2))
			Try
				lcWindow = laStartMouseObj(2).Name
				Activate Window (lcWindow)
				Mouse At  laStartMouseObj(4), laStartMouseObj(3)  Pixels Window (lcWindow)
			Catch
		
			Endtry
		Endif
		
		This.RestoreMyWindowName()
		
		Return
		
		
		
	ENDPROC

	PROCEDURE getcontrolcount		&& Returns the number of child objects in a container object
		Lparameters loObject
		Local lnCount
		
		With loObject
			Do Case
				Case Not This.GetPEMStatus(loObject, 'Objects', 5)
					lnCount = 0
				Case This.GetPEMStatus(loObject, 'ControlCount', 5)
					lnCount = .ControlCount
				Case Inlist(Lower(.BaseClass),[pageframe])
					lnCount = .PageCount
				Case Inlist(Lower(.BaseClass),[grid])
					lnCount = .ColumnCount
				Case Inlist(Lower(.BaseClass),[optiongroup],[commandgroup])
					lnCount = .ButtonCount
				Case Inlist(Lower(.BaseClass),[formset])
					lnCount = .FormCount
				Case Inlist(Lower(.BaseClass),[dataenvironment])
					lnCount = 0
					Do While 'O' = Type(".Objects(lnCount + 1)")
						lnCount = lnCount + 1
					Enddo
				Otherwise
					lnCount = 0
			Endcase
		Endwith
		
		Return lnCount
		
	ENDPROC

	PROCEDURE getcurrentincludefile
		*** JRN 2010-12-28 : Returns name of the Include file for the current open form / class
		
		Local laObjects[1], lcInclude, lcObjectFile
		
		If Aselobj (laObjects, 3) # 0
			lcObjectFile = m.laObjects[2]
			lcInclude	 = m.laObjects[3]
			If File (m.lcInclude)
				Return m.lcInclude
			Endif
		Endif
		
		Return ''
	ENDPROC

	PROCEDURE getincludefiles		&& Returns list of include files
		Lparameters lcSourceText
		
		Local loResult As 'Collection'
		Local lcInclude, lcValue, lnI, loMatches, loRegexp
		
		loRegexp = This.GetRegExp()
		With loRegexp
			.Pattern  = '^\s*#Incl(|u|ud|ude).*$'
			loMatches = .Execute (Strtran(Strtran(lcSourceText, CR + LF, CR), CR, CR + LF))
		Endwith
		
		loResult = Createobject ('Collection')
		For lnI = 0 To loMatches.Count - 1
			lcValue	  = Chrtran (loMatches.Item (lnI).Value, Chr(13) + Chr(10), '')
			lcInclude = Getwordnum (lcValue, 1)
			loResult.Add (Alltrim (Substr (lcValue, At (lcInclude, lcValue) + Len (lcInclude))))
		Endfor
		
		Return loResult
		
	ENDPROC

	PROCEDURE getmousecoordinates
		Local loWas, lcPoint, loResult, lnSMCol, lnSMRow
		
		loWas = Newobject("WinApiSupport", "PEME_WinApiSupport.PRG")
		Declare Long GetCursorPos In WIN32API String @lpPoint
		Declare Long ScreenToClient In WIN32API Long HWnd, String @lpPoint
		
		lcPoint = Replicate(Chr(0), 8)
		&& Get mouse location in Windows desktop coordinates (pixels)
		= GetCursorPos(@lcPoint)
		&& Convert to VFP Desktop (_Screen) coordinates
		= ScreenToClient(_Screen.HWnd, @lcPoint)
		*!*	&& Covert the coordinates to foxels
		
		*!*	lnSMCol = This.Pix2Fox(loWas.Long2Num(Left(lcPoint,4)), .F., _Screen.FontName, _Screen.FontSize)
		*!*	lnSMRow = This.Pix2Fox(loWas.Long2Num(Right(lcPoint,4)), .T., _Screen.FontName, _Screen.FontSize)
		lnSMCol = loWas.Long2Num(Left(lcPoint,4))
		lnSMRow = loWas.Long2Num(Right(lcPoint,4))
		
		loResult = Createobject("Empty")
		AddProperty (loResult, 'Left',   lnSMCol)
		AddProperty (loResult, 'Top',    lnSMRow)
		AddProperty (loResult, 'Source', 'Mouse')
		Return loResult
		
	ENDPROC

	PROCEDURE getmruid		&& Returns the name of the MRU list associated with a file name or extension)
		Lparameters lcFileName
		
		Local lcExt, lcList, lcMRU_ID, lnPos
		lcExt = Upper (Justext ('.' + lcFileName))
		
		lcList = ',VCX=MRUI,PRG=MRUB,MPR=MRUB,QPR=MRUB,SCX=MRUH,MNX=MRUE,FRX=MRUG,DBF=MRUS,DBC=???,LBX=???,PJX=MRUL'
		lnPos  = At (',' + lcExt + '=', lcList)
		If lnPos = 0
			lcMRU_ID = 'MRUC'
		Else
			lcMRU_ID = Substr (lcList, lnPos + 5, 4)
		Endif
		
		Return lcMRU_ID 
	ENDPROC

	PROCEDURE getmrulist		&& Returns (as a collection) the list of all items for a particular MRU list.  <lcMRU_ID> may be the actual MRU name, a file name, or a file extension
		Lparameters lcMRU_ID
		
		#Define DELIMITERCHAR Chr(0)
		
		Local loCollection As 'Collection'
		Local laItems(1), lcData, lcList, lcSourceFile, lnI, lnPos, lnSelect
		
		loCollection = Createobject ('Collection')
		
		If 'ON' # Set ('Resource')
			Return loCollection
		Endif
		
		lnSelect	 = Select()
		lcSourceFile = Set ('Resource', 1)
		Select 0
		Use (lcSourceFile) Again Shared Alias MRU_Resource
		
		If lcMRU_ID # 'MRU'
			lcMRU_ID = This.GetMRUID (lcMRU_ID)
			If '?' $ lcMRU_ID
				Return
			Endif
		Endif
		
		Locate For Id = lcMRU_ID
		If Found()
			lcData = Data
			Alines (laItems, Substr (lcData, 3), 0, DELIMITERCHAR)
			For lnI = 1 To Alen (laItems)
				If Not Empty (laItems (lnI))
					loCollection.Add (laItems (lnI))
				Endif
			Endfor
		Endif
		
		Use
		Select (lnSelect)
		Return loCollection
		
		
	ENDPROC

	PROCEDURE getobjectpath
		Lparameters loObject
		
		Local loTopOfForm As Object
		Local lcCaption
		
		loTopOfForm	= This.FindTopMostParent ()
		
		lcCaption	= ''
		Do While loObject # loTopOfForm
			If Upper(loObject.BaseClass) # "DATAENVIRONMENT"
				lcCaption = '.' + loObject.Name + lcCaption
				If 'O' = Type ('loObject.Parent')
					loObject = loObject.Parent
				Else
					Exit
				Endif
			Else
				lcCaption = loObject.Name + lcCaption
				Exit
			Endif
		Enddo
		
		Return lcCaption
		
	ENDPROC

	PROCEDURE getpemstatus
		Lparameters loObject, lcPEM, nAttribute
		
		If Upper(loObject.BaseClass) = 'OLE'
		
			Local laMembers(1), lnRow
			Amembers(laMembers, loObject, 1, 'PHG#')
			lnRow = Ascan(laMembers, lcPEM, -1, -1, 1, 15)
		
			Do Case
				Case lnRow = 0
					Return .F.
				Case nAttribute = 0 && changed
					Return 'C' $ laMembers(lnRow,3)
				Case nAttribute = 1 && readonly
					Return 'R' $ laMembers(lnRow,3)
				Case nAttribute = 2 && protected
					Return 'P' $ laMembers(lnRow,3)
				Case nAttribute = 3 && type
					Return laMembers(lnRow,2)
				Case nAttribute = 4 && user-defined
					Return 'U' $ laMembers(lnRow,3)
				Case nAttribute = 5 && defined
					Return .T.
				Case nAttribute = 6 && inherited
					Return 'I' $ laMembers(lnRow,3)
			Endcase
		
		Else
		
			Return Pemstatus (loObject, lcPEM, nAttribute)
		
		Endif
		
	ENDPROC

	PROCEDURE getpluginpath
		Lparameters tcPRGFileName
		
		Local lcFileName, lcPRGFileName
		
		lcPRGFileName = m.tcPRGFileName + Iif ('.' $ m.tcPRGFileName, '', '.PRG')
		
		lcFileName = Fullpath('PEME_' + m.lcPRGFileName)
		If File (m.lcFileName)
			Return (m.lcFileName)
		Endif
		
		lcFileName = This.oPEMEditorUtils.cPlugInPath + m.lcPRGFileName
		If File (m.lcFileName)
			Return (m.lcFileName)
		Endif
		
		lcFileName = This.oPEMEditorUtils.cApplicationPath + m.lcPRGFileName
		If File (m.lcFileName)
			Return (m.lcFileName)
		Endif
		
		Return Execscript(_Screen.cThorDispatcher, 'Full Path=PEME_' + m.lcPRGFileName)
		
	ENDPROC

	PROCEDURE getregexp
		Local loRegExp As 'VBScript.RegExp'
		
		loRegExp = Createobject ('VBScript.RegExp')
		With loRegExp
			.IgnoreCase	= .T.
			.Global		= .T.
			.MultiLine	= .T.
		Endwith
		
		Return loRegExp
		
	ENDPROC

	PROCEDURE getrelativepath
		Lparameters lcName, lcPath
		Local lcNew, lnPos, loException
		
		Try
			If Empty (m.lcPath)
				lcNew = Sys(2014, m.lcName)
			Else
				lcNew = Sys(2014, m.lcName, m.lcPath)
			Endif
		Catch To m.loException
			lcNew = m.lcName
		Endtry
		
		If Len (m.lcNew) < Len (m.lcName)
			lnPos = Rat ('..\', m.lcNew)
			If m.lnPos # 0
				lnPos = m.lnPos + 2
			Endif
			Return Left (m.lcNew, m.lnPos) + Right (m.lcName, Len (m.lcNew) - m.lnPos)
		Else
			Return m.lcName
		Endif
		
	ENDPROC

	PROCEDURE getthoroption
		Lparameters lcThorKey, lcThorTool, lxDefaultValue
		Return Nvl(Execscript (_Screen.cThorDispatcher, 'Get Option=', lcThorKey, lcThorTool), lxDefaultValue)
	ENDPROC

	PROCEDURE isnamechar
		Lparameters lcChar
		
		Return Isalpha (lcChar) Or Isdigit (lcChar) Or lcChar = '_'
		
	ENDPROC

	PROCEDURE movewindow
		Local laDims[1], lnCount, lnHeight, lnLeft, lnTop, lnWidth, loEditorWin, lxResult
		
		* Get the whandle for the current window
		loEditorWin	= This.oEditorWin
		lxResult	= m.loEditorWin.FindWindow()
		
		If m.lxResult = -1
			Return
		Endif
		
		If Not Inlist (m.loEditorWin.GetEnvironment(25), 1, 10)
			Return
		Endif
		
		lnCount = Alines (laDims, This.oPrefs.cWindowDimensions, .T., ',')
		
		If m.lnCount >= 1 And Not Empty (m.laDims(1))
			lnLeft = Val (m.laDims(1))
		Else
			lnLeft = m.loEditorWin.GetLeft()
		Endif
		
		If m.lnCount >= 2 And Not Empty (m.laDims(2))
			lnTop = Val (m.laDims(2))
		Else
			lnTop = m.loEditorWin.GetTop()
		Endif
		
		If m.lnCount >= 3 And Not Empty (m.laDims(3))
			lnWidth = Val (m.laDims(3))
		Else
			lnWidth = m.loEditorWin.GetWidth()
		Endif
		lnWidth = Max(100, Min(m.lnWidth, _Screen.Width - m.lnLeft))
		
		If m.lnCount >= 4 And Not Empty (m.laDims(4))
			lnHeight = Val (m.laDims(4))
		Else
			lnHeight = m.loEditorWin.GetHeight()
		Endif
		lnHeight = Max(100, Min(m.lnHeight, _Screen.Height - m.lnTop))
		
		m.loEditorWin.MoveWindow (m.lnLeft, m.lnTop)
		m.loEditorWin.ResizeWindow (m.lnWidth, m.lnHeight)
		
	ENDPROC

	PROCEDURE opemeditorutils_access
		Return _oPEMEditor.oUtils
		
	ENDPROC

	PROCEDURE opemeditor_access
		Return This.oPEMEditorUtils.oPEMEditor
		
	ENDPROC

	PROCEDURE openurl
		******************
		***    Author: Rick Strahl
		***            (c) West Wind Technologies, 1996
		***   Contact: rstrahl@west-wind.com
		***  Modified: 03/14/96
		***  Function: Starts associated Web Browser
		***            and goes to the specified URL.
		***            If Browser is already open it
		***            reloads the page.
		***    Assume: Works only on Win95 and NT 4.0
		***      Pass: tcUrl  - The URL of the site or
		***                     HTML page to bring up
		***                     in the Browser
		***    Return: 2  - Bad Association (invalid URL)
		***            31 - No application association
		***            29 - Failure to load application
		***            30 - Application is busy 
		***
		***            Values over 32 indicate success
		***            and return an instance handle for
		***            the application started (the browser) 
		****************************************************
		LPARAMETERS tcUrl, tcAction, tcDirectory, tcParms
		
		IF EMPTY(tcUrl)
		   RETURN -1
		ENDIF
		IF EMPTY(tcAction)
		   tcAction = "OPEN"
		ENDIF
		IF EMPTY(tcDirectory)
		   tcDirectory = SYS(2023) 
		ENDIF
		
		DECLARE INTEGER ShellExecute ;
		    IN SHELL32.dll ;
		    INTEGER nWinHandle,;
		    STRING cOperation,;
		    STRING cFileName,;
		    STRING cParameters,;
		    STRING cDirectory,;
		    INTEGER nShowWindow
		IF EMPTY(tcParms)
		   tcParms = ""
		ENDIF
		
		DECLARE INTEGER FindWindow ;
		   IN WIN32API ;
		   STRING cNull,STRING cWinName
		
		RETURN ShellExecute(0,;
		                    tcAction,tcUrl,;
		                    tcParms,tcDirectory,1)
		
	ENDPROC

	PROCEDURE oprefs_access
		Return This.oPEMEditorUtils.oPrefs
		
	ENDPROC

	PROCEDURE pix2fox
		LPARAMETER tnPixels, tlVertical, tcFontName, tnFontSize
		&& tnPixels - pixels to convert
		&& tlVertical - .F./.T. convert horizontal/vertical coordinates
		&& tcFontName, tnFontSize - use specified font/size 
		&&         or current form (active output window) font/size, if not specified 
		LOCAL lnFoxels
		 
		IF PCOUNT() > 2
			lnFoxels = tnPixels/FONTMETRIC(IIF(tlVertical, 1, 6), tcFontName, tnFontSize)
		ELSE
			lnFoxels = tnPixels/FONTMETRIC(IIF(tlVertical, 1, 6))
		ENDIF	
		 
		RETURN lnFoxels
	ENDPROC

	PROCEDURE release		&& Releases a FormSet or Form from memory.
		Local laMembers(1), lcMember
		Amembers (laMembers, This, 0)
		For Each lcMember In laMembers
			lcMember = Upper (lcMember)
			If Pemstatus(This, lcMember, 4) And 'O' = Vartype (Getpem (This, lcMember))
				If This.lReleaseOnDestroy
					Try
						This.&lcMember..Release()
					Catch
					Endtry
				Endif
				This.&lcMember. = .Null.
			Endif
		Endfor
		
	ENDPROC

	PROCEDURE showerrormsg
		Lparameters loException, lcTitleBar, lcPRGName, lcAddlInfo
		
		Messagebox ('Error: ' + Transform (loException.ErrorNo) 	+ ccCRLF +							;
			  'Message: ' + loException.Message 					+ ccCRLF +							;
			  'Procedure: ' + IIf (Empty (lcPRGName), loException.Procedure, Justfname (lcPRGName)) + ccCRLF + ;
			  'Line: ' + Transform (loException.Lineno) 			+ ccCRLF +							;
			  'Code: ' + loException.LineContents														;
			  + IIf (Empty (lcAddlInfo), '', ccCRLF + 'NOTES: ' + lcAddlInfo)							;
			  , MB_OK + MB_ICONEXCLAMATION, Evl (lcTitleBar, 'Error'))
		
	ENDPROC

	PROCEDURE showhelp
		Lparameters lnHelpID
		
		Local lcCurrentHelpFile, lcHelpFile, lcPath
		
		lcCurrentHelpFile = Set("Help",1)
		
		lcPath = This.cApplicationPath
		lcHelpFile = lcPath + "PemEditor.CHM"
		
		*** JRN 2010-05-06 : Remove security warning; from http://www.foxpert.com/knowlbits_200906_1.htm
		If File(lcHelpFile)
			PEME_RemSecurityWarning(lcHelpFile)
		
			Set Help To (lcHelpFile)
		
			If Empty (lnHelpID)
				Help
			Else
				Help Id (lnHelpID)
			Endif
		Endif
		
		Set Help To (lcCurrentHelpFile)
		
	ENDPROC

	PROCEDURE striptabs
		Lparameters cAbstract
		
		* Abstract:
		*   Replace all tabs with spaces; also removes leading / trailing blanks
		*
		* Parameters:
		*	<cAbstract> = string to strip tabs/spaces from
		Return Alltrim (Chrtran (m.cAbstract, ccTab, ' '))
		
		
	ENDPROC

	PROCEDURE viewparentcode
		Lparameters lcMethodName, loObject, tlParentage, tlDefaultOnly
		
		*** JRN 12/01/2008 : export list of pems
		Local loTopOfForm As Object
		Local lcFileName, lcObjectName, lcText, lcWindowName
		
		lcText = This.GetAllCode(m.loObject, m.lcMethodName, '', m.tlParentage, m.tlDefaultOnly)
		
		loTopOfForm	 = This.FindTopMostParent ()
		lcObjectName = This.GetObjectPath(m.loObject)
		
		lcWindowName = 'Inherited ' + m.loTopOfForm.Name + m.lcObjectName + '.' + m.lcMethodName + '.' + Substr(Sys(2015), 2) + '.PRG'
		lcFileName	 = Sys(2023) + '\' + m.lcWindowName
		
		Strtofile (m.lcText, m.lcFileName, 0)
		
		****************************************************************
		
		This.ViewTempFile(m.lcFileName)
		
	ENDPROC

	PROCEDURE viewtempfile
		Lparameters lcFileName
		
		Local lcWindowName
		
		lcWindowName = Justfname (m.lcFileName)
		
		*** JRN 12/18/2008 : if already being shown ... close it
		If Wexist (m.lcWindowName)
			Release Windows (m.lcWindowName)
		Endif
		
		*	Modify Command (lcFileName) Nowait Noedit Range 1,1
		Modify Command (m.lcFileName) Nowait Range 1, 1
		
		If This.oPrefs.lAutoMoveWindow
			This.MoveWindow()
		Endif
		
	ENDPROC

ENDDEFINE
